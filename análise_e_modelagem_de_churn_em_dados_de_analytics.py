# -*- coding: utf-8 -*-
"""Análise e Modelagem de Churn em Dados de Analytics

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b6l_yV0UmYljFL5Aac52YqCY5pJjJ4kU
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from tqdm.auto import tqdm
from scipy import stats
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import roc_auc_score

# Carregar o arquivo CSV em um DataFrame
caminho_arquivo = 'data-test-analytics_5.csv'
df = pd.read_csv(caminho_arquivo, encoding='utf-8')

# Converter as datas para o formato datetime
for coluna in ['created_at', 'updated_at', 'last_date_purchase']:
    df[coluna] = pd.to_datetime(df[coluna], errors='coerce')
df['deleted_at'] = df['deleted_at'].apply(lambda x: pd.to_datetime(x, errors='coerce') if x else None)

# Remover colunas não numéricas
colunas_nao_numericas = ['id', 'status', 'created_at', 'updated_at', 'deleted_at', 'marketing_source', 'state']
df_numeric = df.drop(colunas_nao_numericas, axis=1)

# Calcular a matriz de correlação usando o método de Pearson
matriz_correlacao = df_numeric.corr(method='pearson', numeric_only=True)

# Mostrar a matriz de correlação
print(matriz_correlacao)

# Plotar a distribuição do average_ticket
plt.figure(figsize=(10, 6))
sns.histplot(df['average_ticket'].dropna(), kde=False, bins=30)
plt.title('Distribuição do Valor Médio do Pedido')
plt.xlabel('Valor Médio do Pedido')
plt.ylabel('Frequência')
plt.show()

# Plotar a distribuição de items_quantity
plt.figure(figsize=(10, 6))
sns.histplot(df['items_quantity'].dropna(), kde=False, bins=30)
plt.title('Distribuição da Quantidade de Itens')
plt.xlabel('Quantidade de Itens')
plt.ylabel('Frequência')
plt.show()

# Plotar a distribuição de all_revenue
plt.figure(figsize=(10, 6))
sns.histplot(df['all_revenue'].dropna(), kde=False, bins=30)
plt.title('Distribuição da Receita Total')
plt.xlabel('Receita Total')
plt.ylabel('Frequência')
plt.show()

# Plotar a distribuição de all_orders
plt.figure(figsize=(10, 6))
sns.histplot(df['all_orders'].dropna(), kde=False, bins=30)
plt.title('Distribuição do Número Total de Pedidos')
plt.xlabel('Número Total de Pedidos')
plt.ylabel('Frequência')
plt.show()

# Plotar a distribuição de recency
plt.figure(figsize=(10, 6))
sns.histplot(df['recency'].dropna(), kde=False, bins=30)
plt.title('Distribuição da Recência')
plt.xlabel('Recência (dias)')
plt.ylabel('Frequência')
plt.show()

# Plotar a contagem de marketing_source
plt.figure(figsize=(10, 6))
sns.countplot(y='marketing_source', data=df, order=df['marketing_source'].value_counts().index)
plt.title('Contagem da Origem de Marketing')
plt.xlabel('Contagem')
plt.ylabel('Origem de Marketing')
plt.show()

# Analisar a coluna 'status' para entender a taxa de churn
contagem_status_churn = df['status'].value_counts()

# Calcular a taxa de churn
taxa_churn = contagem_status_churn['paused'] / (contagem_status_churn['active'] + contagem_status_churn['paused'])

# Exibir a taxa de churn e as contagens de status
print('Contagem de Status de Churn:\n', contagem_status_churn)
print('\nTaxa de Churn: {:.2%}'.format(taxa_churn))

# Explorar a relação entre churn e outros fatores
# Agrupar por status e calcular a média para colunas numéricas
churn_agrupado = df.groupby('status').mean()

# Exibir os dados agrupados
print('\nAgrupamento por Status e Média:')
print(churn_agrupado)

# Calcular a taxa de churn para o status 'canceled' também
taxa_churn_pausado = contagem_status_churn['paused'] / (contagem_status_churn['active'] + contagem_status_churn['paused'])
taxa_churn_cancelado = contagem_status_churn['canceled'] / (contagem_status_churn['active'] + contagem_status_churn['canceled'])

# Calcular a taxa de churn global incluindo 'paused' e 'canceled'
taxa_churn_global = (contagem_status_churn['paused'] + contagem_status_churn['canceled']) / df['status'].count()

# Exibir as taxas de churn
print('Taxa de Churn (Paused): {:.2%}'.format(taxa_churn_pausado))
print('Taxa de Churn (Canceled): {:.2%}'.format(taxa_churn_cancelado))
print('Taxa de Churn Global: {:.2%}'.format(taxa_churn_global))

# Explorar a relação entre churn e outros fatores
# Agrupar por status e calcular a média para colunas numéricas
churn_agrupado = df.groupby('status').mean()

# Exibir os dados agrupados
print('\nAgrupamento por Status e Média:')
print(churn_agrupado)

# Calcular a taxa de churn para cada origem de marketing
churn_marketing = df.groupby('marketing_source')['status'].apply(lambda x: (x == 'paused').sum() / (x == 'active').sum())

# Ordenar as taxas de churn por origem de marketing
churn_marketing_ordenado = churn_marketing.sort_values(ascending=False)

# Exibir as taxas de churn por origem de marketing
print('\nTaxas de churn por origem de marketing:')
print(churn_marketing_ordenado)

# Analisar a correlação entre a recência das compras e o status de churn
correlacao_recencia_churn = df.groupby('status')['recency'].mean()

# Exibir a correlação entre recência e status de churn
print('\nRecência média por status de churn:')
print(correlacao_recencia_churn)

# Investigar se itens ou serviços específicos estão associados a uma maior taxa de churn
# Para isso, idealmente precisaríamos de dados a nível de item, que não estão presentes no conjunto de dados atual.
# Em vez disso, podemos explorar a correlação entre as variáveis numéricas usando a matriz de correlação
plt.figure(figsize=(10, 6))
sns.heatmap(matriz_correlacao, annot=True, cmap='coolwarm')
plt.title('Matriz de Correlação')
plt.show()